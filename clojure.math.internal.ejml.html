<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clojure.math.internal.ejml documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure-math 1.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="clojure.math.geometry.html"><span>clojure.math.geometry</span></a></li><li><a href="clojure.math.geometry.fit.html"><span>clojure.math.geometry.fit</span></a></li><li><a href="clojure.math.internal.cmath3.html"><span>clojure.math.internal.cmath3</span></a></li><li class="current"><a href="clojure.math.internal.ejml.html"><span>clojure.math.internal.ejml</span></a></li><li><a href="clojure.math.signal.html"><span>clojure.math.signal</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="clojure.math.internal.ejml.html#var-add"><span>add</span></a></li><li><a href="clojure.math.internal.ejml.html#var-det"><span>det</span></a></li><li><a href="clojure.math.internal.ejml.html#var-diag"><span>diag</span></a></li><li><a href="clojure.math.internal.ejml.html#var-eig"><span>eig</span></a></li><li><a href="clojure.math.internal.ejml.html#var-element-div"><span>element-div</span></a></li><li><a href="clojure.math.internal.ejml.html#var-element-mult"><span>element-mult</span></a></li><li><a href="clojure.math.internal.ejml.html#var-from-matrix"><span>from-matrix</span></a></li><li><a href="clojure.math.internal.ejml.html#var-make-matrix"><span>make-matrix</span></a></li><li><a href="clojure.math.internal.ejml.html#var-matrix%3F"><span>matrix?</span></a></li><li><a href="clojure.math.internal.ejml.html#var-max-element"><span>max-element</span></a></li><li><a href="clojure.math.internal.ejml.html#var-min-element"><span>min-element</span></a></li><li><a href="clojure.math.internal.ejml.html#var-mult"><span>mult</span></a></li><li><a href="clojure.math.internal.ejml.html#var-mult-inner"><span>mult-inner</span></a></li><li><a href="clojure.math.internal.ejml.html#var-mult-outer"><span>mult-outer</span></a></li><li><a href="clojure.math.internal.ejml.html#var-norm"><span>norm</span></a></li><li><a href="clojure.math.internal.ejml.html#var-pinv"><span>pinv</span></a></li><li><a href="clojure.math.internal.ejml.html#var-scalar-mult"><span>scalar-mult</span></a></li><li><a href="clojure.math.internal.ejml.html#var-sub"><span>sub</span></a></li><li><a href="clojure.math.internal.ejml.html#var-sum-elements"><span>sum-elements</span></a></li><li><a href="clojure.math.internal.ejml.html#var-svd"><span>svd</span></a></li><li><a href="clojure.math.internal.ejml.html#var-to-matrix"><span>to-matrix</span></a></li><li><a href="clojure.math.internal.ejml.html#var-trans"><span>trans</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>clojure.math.internal.ejml documentation</h2><pre class="doc">Internal interface to EJML library functions and types.
</pre><div class="public" id="var-add"><h3>add</h3><div class="usage"><code>(add a b)</code></div><pre class="doc">Adds matrix B to matrix A.
</pre></div><div class="public" id="var-det"><h3>det</h3><div class="usage"><code>(det m)</code></div><pre class="doc">Computes determinant of the matrix.
</pre></div><div class="public" id="var-diag"><h3>diag</h3><div class="usage"><code>(diag v)</code></div><pre class="doc">Constructs a diagonal matrix from a vector.
</pre></div><div class="public" id="var-eig"><h3>eig</h3><div class="usage"><code>(eig m)</code></div><pre class="doc">Computes eigen-value decomposition of a real matrix m.
Returns a sequence of maps with keys :eigenvalue and :eigenvector.</pre></div><div class="public" id="var-element-div"><h3>element-div</h3><div class="usage"><code>(element-div m1 m2)</code></div><pre class="doc">Computes element-by-element division.
</pre></div><div class="public" id="var-element-mult"><h3>element-mult</h3><div class="usage"><code>(element-mult m1 m2)</code></div><pre class="doc">Computes element-by-element multiplication.
</pre></div><div class="public" id="var-from-matrix"><h3>from-matrix</h3><div class="usage"><code>(from-matrix m)</code></div><pre class="doc">Converts an EJML Matrix64F to a Clojure vector or vectors.
</pre></div><div class="public" id="var-make-matrix"><h3>make-matrix</h3><div class="usage"><code>(make-matrix num-rows num-cols)</code></div><pre class="doc">Creates a new EJML Matrix64F.
</pre></div><div class="public" id="var-matrix%3F"><h3>matrix?</h3><div class="usage"><code>(matrix? m)</code></div><pre class="doc">Returns true if M is not a one-dimensional row (column) vector.
</pre></div><div class="public" id="var-max-element"><h3>max-element</h3><div class="usage"><code>(max-element m)</code></div><pre class="doc">Returns an element with the maximum value.
</pre></div><div class="public" id="var-min-element"><h3>min-element</h3><div class="usage"><code>(min-element m)</code></div><pre class="doc">Returns an element with the minimum value.
</pre></div><div class="public" id="var-mult"><h3>mult</h3><div class="usage"><code>(mult a b)</code></div><pre class="doc">Computes matrix to matrix product.

P = A * B

P_{ij} = \sum_{k=1:n} A_{ik} B_{kj}
</pre></div><div class="public" id="var-mult-inner"><h3>mult-inner</h3><div class="usage"><code>(mult-inner m)</code></div><pre class="doc">Computes the matrix multiplication inner product

P = M' * M

P_{ij} = \sum_{k=1:n} M_{ki} M_{kj}
</pre></div><div class="public" id="var-mult-outer"><h3>mult-outer</h3><div class="usage"><code>(mult-outer m)</code></div><pre class="doc">Computes the matrix multiplication outer product

P = M * M'

P_{ij} = \sum_{k=1:m} M_{ik} M_{jk}
</pre></div><div class="public" id="var-norm"><h3>norm</h3><div class="usage"><code>(norm m)</code><code>(norm m ord)</code></div><pre class="doc">Computes matrix or vector norm.

The following norms can be calculated (similar to NumPy):

====  =============================  ==========================
ord   norm for matrices              norm for vectors
====  =============================  ==========================
0     --                             number of non-zero values
1     max column-sum of abs. values  sum of absolute values
2     2-norm (largest sing. value)   Euclidean norm (default)
:inf  max row-sum of abs. values     max of absolute values
:fro  Frobenius norm (default)       --

</pre></div><div class="public" id="var-pinv"><h3>pinv</h3><div class="usage"><code>(pinv m)</code></div><pre class="doc">Computes the Moore-Penrose pseudo-inverse of M: M^{+} = (M' M)^{-1} M'.
</pre></div><div class="public" id="var-scalar-mult"><h3>scalar-mult</h3><div class="usage"><code>(scalar-mult a alpha)</code></div><pre class="doc">Multiplies matrix A by a scalar alpha.
</pre></div><div class="public" id="var-sub"><h3>sub</h3><div class="usage"><code>(sub a b)</code></div><pre class="doc">Subtracts matrix B from matrix A.
</pre></div><div class="public" id="var-sum-elements"><h3>sum-elements</h3><div class="usage"><code>(sum-elements m)</code></div><pre class="doc">Computes a sum of all elements.
</pre></div><div class="public" id="var-svd"><h3>svd</h3><div class="usage"><code>(svd m &amp; {:keys [compact compute-uv order], :or {compact true, compute-uv true, order true}})</code></div><pre class="doc">Computes singular value decomposition of matrix M as M = U * S * V',
where U and V are orthogonal, and S is diagonal. Returns a map with
keys :u, :s (a vector of singular values), and :v. May return nil
if decomposition fails.

Keyword arguments:

:compact     If false and M is m x n, the matrices U and V' are square m
             x m and n x n respectively.  If true and M is m x n,
             svd calculates only the first k columns of U, and the
             first k rows of V', where k = min(m, n).
             (default: false)

:compute-uv  If false, svd calculates only a vector of singular
             values :s. If true, svd calculates U and V in
             addition to S. (default: true)

:order       If false, singular values are not ordered.
             If true, singular values are given in decreasing order.
             (default: true)</pre></div><div class="public" id="var-to-matrix"><h3>to-matrix</h3><div class="usage"><code>(to-matrix seq-of-seqs)</code></div><pre class="doc">Converts a sequences of sequences to a new EJML Matrix64F.
</pre></div><div class="public" id="var-trans"><h3>trans</h3><div class="usage"><code>(trans m)</code></div><pre class="doc">Transposes matrix.
</pre></div></div></body></html>